

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HDF5_BLS.analyze &mdash; HDF5_BLS v1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=76e2d817"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            HDF5_BLS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/HDF5_BLS.html">HDF5_BLS</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HDF5_BLS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">HDF5_BLS.analyze</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for HDF5_BLS.analyze</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>

<div class="viewcode-block" id="Analyze">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Analyze</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class is the base class for all the analyze classes. It provides a common interface for all the classes. Its purpose is to provide the basic silent functions to open, create and save algorithms, and to store the different steps of the analysis and their effects on the data.</span>
<span class="sd">    The philosophy of this class is to rely on 4 attributes that will be changed by the different functions of the class:</span>
<span class="sd">    - x: the x-axis of the data</span>
<span class="sd">    - y: the y-axis of the data</span>
<span class="sd">    - points: a list of remarkable points in the data where each point is a 2-list of the form [position, type]</span>
<span class="sd">    - windows: a list of windows in the data where each window is a 2-list of the form [start, end]</span>
<span class="sd">    And to store the different steps of the analysis and their effects on the data:</span>
<span class="sd">    - _algorithm: a dictionary that stores the name of the algorithm, its version, the author, and a description</span>
<span class="sd">    - _history: a list that stores the evolution of the 4 main attributes of the class with the steps of the analysis.</span>
<span class="sd">    The data is defined by 2 1-D arrays: x and y. Additionally, remarkable points and windows are stored in the points and windows attributes.</span>
<span class="sd">    Algorithm steps are stored in 2 attributes: _algorithm and _history. The _algorithm attribute is a dictionary that stores the name of the algorithm, its version, the author, and a description. The _history attribute is a list that stores the steps of the analysis and their effects on the data.</span>
<span class="sd">    The _execute attribute is a boolean that indicates whether the analysis should be executed or not. It is set to True by default. The _auto_run attribute is a boolean that indicates whether the analysis should be executed automatically or not. It is set to False by default.</span>
<span class="sd">    As a general rule, we encourage developers not to modify any of the underscore-prefixed attributes. These attributes are meant to be used internally by the mother class to run, save, and load the analysis and its history.</span>
<span class="sd">    All the functions of the class are functions with a zero-argument call signature that returns None. This means that the parameters of the methods of the children class need to be kew-word arguments, and that if no value for these arguments are given, the default value of the arguments leads the function to do nothing. This specificality ensures the modulability of the class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        The x-axis of the data.</span>
<span class="sd">    y : np.ndarray</span>
<span class="sd">        The y-axis of the data.</span>
<span class="sd">    points : list of 2-list</span>
<span class="sd">        A list of remarkable points in the data where each point is a 2-list of the form [position, type].</span>
<span class="sd">    windows : list of 2-list</span>
<span class="sd">        A list of windows in the data where each window is a 2-list of the form [start, end].</span>
<span class="sd">    _algorithm : dict</span>
<span class="sd">        The algorithm used to analyze the data.</span>
<span class="sd">    _history : list</span>
<span class="sd">        The history of the analysis.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_record_algorithm</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># This attribute is used to record the steps of the analysis</span>
    <span class="n">_save_history</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># This attribute is used to save the effects of the steps of the analysis on the data</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the class with the most basic attributes: the ordinates and abscissa of the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array</span>
<span class="sd">            The array of ordinates of the data</span>
<span class="sd">        x : array, optional</span>
<span class="sd">            The array of abscissa of the data. If None, the abscissa is just the index of the points in ordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_history_base</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is used to override the __getattribute__ function of the class. It is used to keep track of the history of the algorithm, its impact on the classes attributes, and to store the algorithm in the _algorithm attribute so as to be able to save it or run it later.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of a function of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The result of the function call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If the attribute is a function, we call it with the given arguments</span>
        <span class="n">attribute</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># Extract the description of the function from the docstring</span>
                <span class="n">docstring</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getdoc</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">docstring</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">docstring</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

                <span class="c1"># Get the default parameter values from the function signature</span>
                <span class="n">signature</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span>
                <span class="n">default_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
                <span class="p">}</span>

                <span class="c1"># Merge default kwargs with provided kwargs</span>
                <span class="n">merged_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">default_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">}</span>

                <span class="c1"># If the attribute _record_algorithm is True, add the function to the algorithm</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_algorithm</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                        <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="n">merged_kwargs</span><span class="p">,</span>
                        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">description</span>
                    <span class="p">})</span>

                <span class="c1"># Store the attributes of the class in memory to compare them to the ones after the function is run</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">:</span>
                    <span class="n">temp_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">temp_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">temp_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">p</span><span class="p">,</span> <span class="n">tp</span><span class="p">]</span> <span class="k">for</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">tp</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">]</span>
                    <span class="n">temp_windows</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="p">]</span>

                <span class="c1"># Run the function</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">attribute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

                <span class="c1"># If the attribute _save_history is True, compare the attributes of the class with the ones stored in memory and update the history if needed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;function&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">})</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">temp_x</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">temp_y</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">!=</span> <span class="n">temp_points</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">==</span> <span class="p">[]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">!=</span> <span class="n">temp_windows</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">==</span> <span class="p">[]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;windows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">else</span><span class="p">:</span>    
                            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;windows&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># This is to store the initial value of the x and y arrays</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history_base</span><span class="p">)</span>
                
                <span class="k">return</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">wrapper</span>
        <span class="k">return</span> <span class="n">attribute</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">algorithm_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;Unnamed Algorithm&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="s2">&quot;0.1&quot;</span><span class="p">,</span> <span class="n">author</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Unknown&quot;</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a new JSON algorithm with the given name, version, author and description. This algorithm is stored in the _algorithm attribute. This function also creates an empty history. for the software.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        algorithm_name : str, optional</span>
<span class="sd">            The name of the algorithm, by default &quot;Unnamed Algorithm&quot;</span>
<span class="sd">        version : str, optional</span>
<span class="sd">            The version of the algorithm, by default &quot;0.1&quot;</span>
<span class="sd">        author : str, optional</span>
<span class="sd">            The author of the algorithm, by default &quot;Unknown&quot;</span>
<span class="sd">        description : str, optional</span>
<span class="sd">            The description of the algorithm, by default &quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">algorithm_name</span><span class="p">,</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="n">version</span><span class="p">,</span>
            <span class="s2">&quot;author&quot;</span><span class="p">:</span> <span class="n">author</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="n">description</span><span class="p">,</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_move_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">new_step</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Moves a step from one position to another in the _algorithm attribute. Deletes the elements of the _history attribute that are after the moved step (included)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : int</span>
<span class="sd">            The position of the function to move in the _algorithm attribute.</span>
<span class="sd">        new_step : int</span>
<span class="sd">            The new position to move the function to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Moves the step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">new_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>

        <span class="c1"># Deletes the elements of the _history attribute that are after the moved step (included)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">new_step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[:</span><span class="n">new_step</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens an existing JSON algorithm and stores it in the _algorithm attribute. This function also creates an empty history.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str, optional</span>
<span class="sd">            The filepath to the JSON algorithm, by default None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensures that the filepath is not None</span>
        <span class="k">if</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> 
        
        <span class="c1"># Open the JSON file, stores it in the _algorithm attribute and creates an empty history</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes the step from the _history attribute of the class. If no step is given, removes the last step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            The number of the function up to which the algorithm has to be run. Default is None, means that the last step is removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If no step is given, set the step to the last step</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Ensures that the step is within the range of the functions list</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The step parameter has to be a positive integer smaller than the number of functions (here </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">).&quot;</span><span class="p">)</span>
        
        <span class="c1"># Removes the step from the _algorithm attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

        <span class="c1"># Removes all steps after the removed step (included) from the _history attribute</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[:</span><span class="n">step</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_run_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Runs the algorithm stored in the _algorithm attribute of the class up to the given step (included). If no step is given, the algorithm is run up to the last step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step : int, optional</span>
<span class="sd">            The number of the function up to which the algorithm has to be run (included), by default None means that all the steps of the algorithm are run.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">run_step_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Runs the algorithm stored in the _algorithm attribute of the class. This function can also run up to a specific step of the algorithm.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            step : int</span>
<span class="sd">                The number of the function up to which the algorithm has to be run.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="n">step</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">][</span><span class="n">step</span><span class="p">][</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)):</span>
                <span class="n">func_to_call</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>
                <span class="n">func_to_call</span><span class="p">(</span><span class="o">**</span><span class="n">parameters</span><span class="p">)</span>
                        
        <span class="k">def</span><span class="w"> </span><span class="nf">extract_parameters_from_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Extracts the parameters from the _history attribute of the class up to the given step.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            step : int</span>
<span class="sd">                The number of the function up to which the algorithm has to be run.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Goes through the steps of the _history attribute up to the given step (excluded) and updates the attributes of the class</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">step</span><span class="p">):</span>
                <span class="n">hist_step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">hist_step</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hist_step</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">hist_step</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hist_step</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span>
                <span class="k">if</span> <span class="s2">&quot;points&quot;</span> <span class="ow">in</span> <span class="n">hist_step</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">hist_step</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="s2">&quot;windows&quot;</span> <span class="ow">in</span> <span class="n">hist_step</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">=</span> <span class="n">hist_step</span><span class="p">[</span><span class="s2">&quot;windows&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># If the step is None, set the step to the length of the functions list</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Ensures that the step is within the range of the functions list</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s2">&quot;functions&quot;</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The step parameter has to be a positive integersmaller than the number of functions (here </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="s1">&#39;functions&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">). The step value given was </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Sets the _record_algorithm attribute to False to avoid recording the steps in the _algorithm attributes when running the __getattribute__ function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_algorithm</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># In the particular case where the first step is to be run, we start by retrieving the parameters of the first step from the _history_base attribute, then we remove the first element of the _history attribute and run the functions sequentially from there, up to the given step</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Reinitialize the points and windows attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Reinitialize the _history attribute</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Reinitialize the x and y attributes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history_base</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history_base</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
            
            <span class="c1"># Run the first step</span>
            <span class="n">run_step_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Makes sure that the x and y attributes are stored in the history</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> 
                <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># If now we want to run another step, look at the _history attribute to extract the parameters that have been stored up to the current step (or the last step stored in the _history attribute), limit the _history attribute to the current step and run the functions sequentially from there, up to the given step</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If we want to execute a step that was previously executed and whose results were stored in the _history attribute:</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">):</span>
                <span class="c1"># Reduce the _history attribute to the given step (excluded)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">[:</span><span class="n">step</span><span class="p">]</span>

                <span class="c1"># Extract the parameters from the _history attribute up to the given step (exlucded)</span>
                <span class="n">extract_parameters_from_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

            <span class="c1"># If now we want to execute a step that is beyond what was previously executed, we need to run all the steps from the last stored step to the given step</span>
            <span class="k">elif</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">):</span>
                <span class="c1"># In the particular case where no steps are stored, we run the first step of the algorithm recursively. This reinitializes the points and windows attributes, the _history attribute, and the x and y attributes</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_run_algorithm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">first_step</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># If some steps are stored, we update the attributes using the parameters stored in the _history attribute and run from there</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extract_parameters_from_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">))</span>
                    <span class="n">first_step</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_history</span><span class="p">)</span>

                <span class="c1"># Run the steps from the last stored step to the given step (excluded)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_step</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
                    <span class="n">run_step_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="c1"># Run the selected step</span>
            <span class="n">run_step_save_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_record_algorithm</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_save_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;algorithm.json&quot;</span><span class="p">,</span> <span class="n">save_parameters</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Saves the algorithm to a JSON file with or without the parameters used. If the parameters are not saved, their value is set to a default value proper to their type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filepath : str, optional</span>
<span class="sd">            The filepath to save the algorithm to. Default is &quot;algorithm.json&quot;.</span>
<span class="sd">        save_parameters : bool, optional</span>
<span class="sd">            Whether to save the parameters of the functions. Default is False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
    



        <span class="c1"># Creates a local dictionary to store the algorithm to save. This allows to reinitiate the parameters if needed.</span>
        <span class="n">algorithm_loc</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Then go through the keys of the algorithm</span>
        <span class="c1"># for k in self._algorithm.keys():</span>
        <span class="c1">#     # In particular for functions, if we don&#39;t want to save the parameters, we reinitiate them to empty lists or dictionaries</span>
        <span class="c1">#     if k == &quot;functions&quot;:</span>
        <span class="c1">#         algorithm_loc[k] = []</span>
        <span class="c1">#         for f in self._algorithm[k]:</span>
        <span class="c1">#             algorithm_loc[k].append({})</span>
        <span class="c1">#             algorithm_loc[k][-1][&quot;function&quot;] = f[&quot;function&quot;]</span>
        <span class="c1">#             if not save_parameters:</span>
        <span class="c1">#                 for k_param in f[&quot;parameters&quot;].keys():</span>
        <span class="c1">#                     if type(f[&quot;parameters&quot;][k_param]) == list:</span>
        <span class="c1">#                         f[&quot;parameters&quot;][k_param] = []</span>
        <span class="c1">#                     elif type(f[&quot;parameters&quot;][k_param]) == dict:</span>
        <span class="c1">#                         f[&quot;parameters&quot;][k_param] = {}</span>
        <span class="c1">#                     else:</span>
        <span class="c1">#                         f[&quot;parameters&quot;][k_param] = None</span>
        <span class="c1">#             algorithm_loc[k][-1][&quot;parameters&quot;] = f[&quot;parameters&quot;]</span>
        <span class="c1">#             algorithm_loc[k][-1][&quot;description&quot;] = f[&quot;description&quot;]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># In particular for functions, if we don&#39;t want to save the parameters, we reinitiate them to empty lists or dictionaries</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;functions&quot;</span><span class="p">:</span>
                <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                    <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>
                    <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;function&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">save_parameters</span><span class="p">:</span>
                        <span class="n">sgn</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;function&quot;</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sgn</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;self&quot;</span><span class="p">:</span>
                                <span class="n">f</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">default</span>
                    <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;parameters&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;description&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">]</span>
            <span class="c1"># Otherwise we just copy the value of the key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">algorithm_loc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="c1"># We save the algorithm to the given filepath</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">algorithm_loc</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="Analyze_general">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_general">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Analyze_general</span><span class="p">(</span><span class="n">Analyze</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class is a class inherited from the Analyze class used to store steps of analysis that are not specific to a particular type of spectrometer and that are not interesting to show in an algorithm. For example, the function to add a remarkable point to the data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">type_pnt</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds points to the points dictionary and a window to the windows dictionary</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : float</span>
<span class="sd">            The x-value of the point.</span>
<span class="sd">        type : str</span>
<span class="sd">            The type of the point.</span>
<span class="sd">        window : tuple</span>
<span class="sd">            The window around the point to refine its position</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Initiate a counter to count the number of these kind of peaks</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">nme</span> <span class="o">=</span> <span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">type_pnt</span> <span class="o">==</span> <span class="n">nme</span><span class="p">:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Add the point to the list of points and the list of windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">type_pnt</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_history</span> <span class="o">=</span> <span class="n">temp</span>

        <span class="k">if</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">windows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_clear_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the list of points and the list of windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">windows</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_refine_peak_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Refines the position of a peak based on a window surrounding it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        window : list, optional</span>
<span class="sd">            The window surrounding the peak. The format is [start, end]. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _type_</span>
<span class="sd">            _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract the windowed abscissa and ordinate arrays</span>
        <span class="n">wndw_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">wndw_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]))]</span>

        <span class="c1"># Fit a quadratic polynomial to the windowed data and returns the local extremum</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">wndw_x</span><span class="p">,</span> <span class="n">wndw_y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_x</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_return_string_algorithm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a string representation of the algorithm stored in the _algorithm attribute of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The string representation of the algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>


<div class="viewcode-block" id="Analyze_VIPA">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Analyze_VIPA</span><span class="p">(</span><span class="n">Analyze_general</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class is a child class of Analyze_general. It inherits all the methods of the parent class and adds the functions specific to VIPA spectrometers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_algorithm</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;VIPA spectrum analyzer&quot;</span><span class="p">,</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="s2">&quot;0.0&quot;</span><span class="p">,</span>
            <span class="s2">&quot;author&quot;</span><span class="p">:</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;A blank algorithm for VIPA spectrometers.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;functions&quot;</span><span class="p">:</span> <span class="p">[]</span>
        <span class="p">}</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">_history</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Analyze_VIPA.add_point">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA.add_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position_center_window</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">window_width</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type_pnt</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Elastic&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single point to the list of points together with a window to the list of windows with its type. Each point is an intensity extremum obtained by fitting a quadratic polynomial to the windowed data.</span>
<span class="sd">        The point is given as a value on the x axis (not a position).</span>
<span class="sd">        The &quot;position_center_window&quot; parameter is the center of the window surrounding the peak. The &quot;window_width&quot; parameter is the width of the window surrounding the peak (full width). The &quot;type_pnt&quot; parameter is the type of the peak. It can be either &quot;Stokes&quot;, &quot;Anti-Stokes&quot; or &quot;Elastic&quot;.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        position_center_window : float</span>
<span class="sd">            A value on the self.x axis corresponding to the center of a window surrounding a peak</span>
<span class="sd">        window : float</span>
<span class="sd">            A value on the self.x axis corresponding to the width of a window surrounding a peak</span>
<span class="sd">        type_pnt : str</span>
<span class="sd">            The nature of the peak. Must be one of the following: &quot;Stokes&quot;, &quot;Anti-Stokes&quot; or &quot;Elastic&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Base case: if any of the parameters is None, return</span>
        <span class="k">if</span> <span class="n">window_width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Check that the type of the point is correct</span>
        <span class="k">if</span> <span class="n">type_pnt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Stokes&quot;</span><span class="p">,</span> <span class="s2">&quot;Anti-Stokes&quot;</span><span class="p">,</span> <span class="s2">&quot;Elastic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The type of the point must be one of the following: &#39;Stokes&#39;, &#39;Anti-Stokes&#39; or &#39;Elastic&#39;. Here the value given was &#39;</span><span class="si">{</span><span class="n">type_pnt</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># Check that the window is in the range of the data</span>
        <span class="n">window</span> <span class="o">=</span> <span class="p">[</span><span class="n">position_center_window</span><span class="o">-</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">position_center_window</span><span class="o">+</span><span class="n">window_width</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The window </span><span class="si">{</span><span class="n">window</span><span class="si">}</span><span class="s2"> is out of the range of the data&quot;</span><span class="p">)</span>
        
        <span class="c1"># Ensure that the window is within the range of the data</span>
        <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Refine the position of the peaks</span>
        <span class="n">new_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refine_peak_position</span><span class="p">(</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span><span class="p">)</span>

        <span class="c1"># Add the point to the list of points and the list of windows using the silent method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_point</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">type_pnt</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span></div>

        
<div class="viewcode-block" id="Analyze_VIPA.center_x_axis">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA.center_x_axis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">center_x_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers the x axis using the first points stored in the class. The parameter &quot;center_type&quot; is used to determine wether to center the axis using the first elastic peak (center_type = &quot;Elastic&quot;) or the average of two Stokes and Anti-Stokes peaks (center_type = &quot;Inelastic&quot;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        center_type: str</span>
<span class="sd">            The type of the peak to center the x axis around. Must be either &quot;Elastic&quot; or &quot;Inelastic&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Base case: if center_type is None, return</span>
        <span class="k">if</span> <span class="n">center_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> 
        
        <span class="c1"># Check that type is either &quot;Elastic&quot; or &quot;Inelastic&quot; </span>
        <span class="k">if</span> <span class="n">center_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Elastic&quot;</span><span class="p">,</span> <span class="s2">&quot;Inelastic&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The attribute &#39;center_type&#39; must be either &#39;Elastic&#39; or &#39;Inelastic&#39;&quot;</span><span class="p">)</span>
       
        <span class="c1"># If type is &quot;Elastic&quot;, center the x axis around the elastic peak or raise an error if there is no elastic peak</span>
        <span class="k">if</span> <span class="n">center_type</span> <span class="o">==</span> <span class="s2">&quot;Elastic&quot;</span><span class="p">:</span>
            <span class="n">not_in_list</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">point</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Elastic_0&quot;</span><span class="p">:</span>
                    <span class="n">v_E</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">not_in_list</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">not_in_list</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There is no elastic peak stored in the class&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">v_E</span>
        <span class="c1"># If type is &quot;Inelastic&quot;, center the x axis around the average of the Stokes and Anti-Stokes peaks or raise an error if there is no Stokes and Anti-Stokes peaks</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_in_list_AS</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">not_in_list_S</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">point</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Stokes_0&quot;</span><span class="p">:</span>
                    <span class="n">v_S</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">not_in_list_S</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;Anti-Stokes_0&quot;</span><span class="p">:</span>
                    <span class="n">v_AS</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="n">not_in_list_AS</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">not_in_list_AS</span> <span class="ow">or</span> <span class="n">not_in_list_S</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There are no Stokes and Anti-Stokes peaks stored in the class&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">v_S</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">v_AS</span><span class="o">/</span><span class="mi">2</span>
        
        
        <span class="c1"># Clear the points and windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_points</span><span class="p">()</span>
        
        <span class="c1"># Return the x axis if the user wants to use it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span></div>


<div class="viewcode-block" id="Analyze_VIPA.interpolate_elastic_inelastic">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA.interpolate_elastic_inelastic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate_elastic_inelastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">FSR</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses the elastic peaks, and the positions of the Brillouin peaks on the different orders to obtain a frequency axis by interpolating the position of the peaks with a quadratic polynomial. The user can either enter a value for the shift or the FSR, or both. The shift value is used to calibrate the frequency axis using known values of shifts when using a calibration sample to obtain the frequency axis. The FSR value is used to calibrate the frequency axis using a known values of FSR for the VIPA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------  </span>
<span class="sd">        shift : float</span>
<span class="sd">            The shift between the elastic and inelastic peaks (in GHz).</span>
<span class="sd">        FSR : float</span>
<span class="sd">            The free spectral range of the VIPA spectrometer (in GHz).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_order</span><span class="p">(</span><span class="n">AS</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
            <span class="n">AS_order</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">AS</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">e</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">temp</span><span class="p">]):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">AS_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AS_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">AS_order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">AS_order</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">AS</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">AS_order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">S_order</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">S</span><span class="p">:</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">e</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">E</span><span class="p">[</span><span class="n">temp</span><span class="p">]):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">S_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S_order</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">S_order</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">S_order</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">S</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">S_order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">AS_order</span><span class="p">,</span> <span class="n">S_order</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_matrices</span><span class="p">(</span><span class="n">AS</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">AS_order</span><span class="p">,</span> <span class="n">S_order</span><span class="p">):</span>
            <span class="c1"># Create the matrices that will be used to minimize the second order polynomial</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># Ensuring that the difference between antistokes and stokes is the same for all orders</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">AS_order</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_order</span><span class="p">))</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">AS_order</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_order</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">AS_0</span> <span class="o">=</span> <span class="n">AS</span><span class="p">[</span><span class="n">AS_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                <span class="n">S_0</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">S_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                <span class="n">AS_1</span> <span class="o">=</span> <span class="n">AS</span><span class="p">[</span><span class="n">AS_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">S_1</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">S_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">S_1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">AS_0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S_0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS_1</span> <span class="o">-</span> <span class="n">S_1</span> <span class="o">-</span> <span class="n">AS_0</span> <span class="o">+</span> <span class="n">S_0</span><span class="p">)</span>
                <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">FSR</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#Ensuring that the distance between two neighboring stokes peaks is one FSR</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">FSR</span><span class="p">)</span>
                <span class="c1">#Ensuring that the distance between two neighboring anti-stokes peaks is one FSR</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">AS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">AS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">AS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">FSR</span><span class="p">)</span>
                <span class="c1">#Ensuring that the distance between two neighboring elastic peaks is one FSR</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">FSR</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">shift</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">AS_order</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_order</span><span class="p">))</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">AS_order</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_order</span><span class="p">)):</span>
                    <span class="n">AS</span> <span class="o">=</span> <span class="n">AS</span><span class="p">[</span><span class="n">AS_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">S_order</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                    <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AS</span> <span class="o">-</span> <span class="n">S</span><span class="p">)</span>
                    <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
                    <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shift</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">FSR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="c1"># Start by extracting the stokes, anti-Stokes and elastic peaks</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">AS</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span>
                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
                <span class="n">AS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">AS_order</span><span class="p">,</span> <span class="n">S_order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">AS</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
        
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">create_matrices</span><span class="p">(</span><span class="n">AS</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">AS_order</span><span class="p">,</span> <span class="n">S_order</span><span class="p">)</span>
       
        <span class="c1"># Converting the lists to numpy arrays</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="c1"># Defining the minimization function</span>
        <span class="k">if</span> <span class="n">FSR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">AS_order</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_order</span><span class="p">))</span><span class="o">*</span><span class="n">FSR</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">)</span>
        
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>

        <span class="c1"># Now we can create the new x axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span>

        <span class="c1"># Clear the points and windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_points</span><span class="p">()</span>

        <span class="c1"># Return the x axis if the user wants to use it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span></div>


<div class="viewcode-block" id="Analyze_VIPA.interpolate_between_one_order">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA.interpolate_between_one_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate_between_one_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FSR</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a frequency axis by using the signal between two elastic peaks included. By imposing that the distance in frequency between two neighboring elastic peaks is one FSR, and that the shift of both stokes and anti-stokes peaks to their respective elastic peak is the same, we can obtain a frequency axis. The user has to enter a value for the FSR to calibrate the frequency axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------  </span>
<span class="sd">        FSR : float</span>
<span class="sd">            The free spectral range of the VIPA spectrometer (in GHz).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">FSR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="c1"># Start by extracting the elastic peaks</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">AS</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span>
                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">:</span>
                <span class="n">AS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span>
                <span class="n">S</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be exactly one anti-Stokes peak to use this function.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;There must be exactly one Stokes peak to use this function.&quot;</span><span class="p">)</span>

        <span class="n">E</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">AS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x3</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Create the matrices that will be used to minimize the second order polynomial</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">x3</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x0</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">x3</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x0</span><span class="o">-</span><span class="n">x3</span><span class="o">+</span><span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span>  <span class="n">FSR</span><span class="o">*</span><span class="n">temp</span><span class="o">/</span><span class="n">denom</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">FSR</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">x3</span><span class="o">-</span><span class="n">x0</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">x3</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x0</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">freq</span><span class="p">:</span> <span class="n">a</span><span class="o">*</span><span class="n">freq</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">freq</span>
        <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">f</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>  

        <span class="c1"># Now we can create the new x axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span>

        <span class="c1"># Clear the points and windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_points</span><span class="p">()</span>

        <span class="c1"># Return the x axis if the user wants to use it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span></div>


<div class="viewcode-block" id="Analyze_VIPA.interpolate_elastic">
<a class="viewcode-back" href="../../_autosummary/HDF5_BLS.analyze.html#HDF5_BLS.analyze.Analyze_VIPA.interpolate_elastic">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate_elastic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">FSR</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Uses positions of the elastic peaks on the different orders, to obtain a frequency axis by interpolating the position of the peaks with a quadratic polynomial. The user has to enter a value for the FSR to calibrate the frequency axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------  </span>
<span class="sd">        FSR : float</span>
<span class="sd">            The free spectral range of the VIPA spectrometer (in GHz).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">create_matrices</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="c1"># Create the matrices that will be used to minimize the second order polynomial</span>
            <span class="n">A</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">B</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">C</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">B</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">C</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">FSR</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">params</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">a</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">B</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="n">C</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">FSR</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        
        <span class="c1"># Start by extracting the stokes, anti-Stokes and elastic peaks</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">point</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;E&quot;</span><span class="p">:</span>
                <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        
        <span class="n">E</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">create_matrices</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
       
        <span class="c1"># Converting the lists to numpy arrays</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="c1"># Defining the minimization function</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">error</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">*</span><span class="n">FSR</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">)</span>
        
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>

        <span class="c1"># Now we can create the new x axis</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">c</span>

        <span class="c1"># Clear the points and windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_points</span><span class="p">()</span>

        <span class="c1"># Return the x axis if the user wants to use it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span></div>
</div>



<span class="c1"># Example Usage</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s2">&quot;/Users/pierrebouvet/Documents/Databases/2504 - Measures fixed cells/Test.h5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s2">&quot;Brillouin/HCU29/HCU29 - 1/Acq 1/Raw data&quot;</span><span class="p">][()])</span>
    
    <span class="n">average</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">average</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">average</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">average</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">analyzer</span> <span class="o">=</span> <span class="n">Analyze_VIPA</span><span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">average</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">y</span> <span class="o">=</span> <span class="n">average</span><span class="p">)</span>
   
    <span class="c1"># analyzer._create_algorithm(algorithm_name=&quot;VIPA spectrum analyzer&quot;, </span>
    <span class="c1">#                            version=&quot;v0&quot;, </span>
    <span class="c1">#                            author=&quot;Pierre Bouvet&quot;, </span>
    <span class="c1">#                            description=&quot;This algorithm allows the user to recover a frequency axis basing ourselves on a single Brillouin spectrum obtained with a VIPA spectrometer. Considering that only one Brillouin Stokes and anti-Stokes doublet is visible on the spectrum, the user can select the peaks he sees, and then perform a quadratic interpolation to obtain the frequency axis. This interpolation is obtained either by entering a value for the Brillouin shift of the material or by entering the value of the Free Spectral Range (FSR) of the spectrometer. The user can finally recenter the spectrum either using the average between a Stokes and an anti-Stokes peak or by choosing an elastic peak as zero frequency.&quot;)</span>
    <span class="c1"># analyzer.add_point(position_center_window=12, type_pnt=&quot;Elastic&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=37, type_pnt=&quot;Anti-Stokes&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=236, type_pnt=&quot;Stokes&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=259, type_pnt=&quot;Elastic&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=282, type_pnt=&quot;Anti-Stokes&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=466, type_pnt=&quot;Stokes&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=488, type_pnt=&quot;Elastic&quot;, window_width=5)</span>
    <span class="c1"># analyzer.add_point(position_center_window=509, type_pnt=&quot;Anti-Stokes&quot;, window_width=5)</span>
    <span class="c1"># analyzer.interpolate_elastic_inelastic(FSR = 60)</span>
    <span class="c1"># analyzer.add_point(position_center_window=57, type_pnt=&quot;Stokes&quot;, window_width=1)</span>
    <span class="c1"># analyzer.add_point(position_center_window=68.5, type_pnt=&quot;Anti-Stokes&quot;, window_width=1)</span>
    <span class="c1"># analyzer.center_x_axis(center_type = &quot;Inelastic&quot;)</span>

    <span class="c1"># analyzer._save_algorithm(filepath = &quot;algorithms/Analysis/VIPA spectrometer/Test.json&quot;, save_parameters=True)</span>
    
    <span class="n">analyzer</span><span class="o">.</span><span class="n">_open_algorithm</span><span class="p">(</span><span class="n">filepath</span> <span class="o">=</span> <span class="s2">&quot;algorithms/Analysis/VIPA spectrometer/MUW_PB_VIPA_FSR_Shift_v0.json&quot;</span><span class="p">)</span>
    <span class="n">analyzer</span><span class="o">.</span><span class="n">_run_algorithm</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">analyzer</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">analyzer</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># analyzer._print_algorithm()</span>


    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Pierre Bouvet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>