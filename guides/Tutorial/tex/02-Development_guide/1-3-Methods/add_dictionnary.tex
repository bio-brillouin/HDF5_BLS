This method is the preferred way to add data to the wrapper. It allows the user to create a dictionary with the data and the attributes of the data he wants to add to the file. 

\begin{lstlisting}
def add_dictionnary(self, dic, parent_group = None, name_group = None, brillouin_type = "Measure", overwrite = False):
\end{lstlisting}

\paragraph{Attributes:}

\begin{itemize}
    \item \textbf{dic}: The dictionnary to add to the wrapper. This dictionnary has a preferred nomenclature for its keys that will allow the addition of the data with specific attributes to our file format. These keys are identical to the Brillouin\_types for dataset defined in \hyperref[subsec:preamble.file_structure.complete_structure]{preamble}. Each element of the dictionnary is another dictionnary with the following keys:
    \begin{itemize}
        \item "Name": The name of the dataset that will be stored. This can be any name that the user wants and find useful.
        \item "Data": The array that will be stored, or the dictionnary if we are adding attributes
        \item "Unit": \textit{Specific to "Abscissa\_..." keys}. The unit of the abscissa
        \item "Dim\_start": \textit{Specific to "Abscissa\_..." keys}. The first dimension to which the abscissa corresponds.
        \item "Dim\_end": \textit{Specific to "Abscissa\_..." keys}. The last dimension (excluded) to which the abscissa corresponds
    \end{itemize}
    \item \textbf{parent\_group} \textit{(optional, default None)}: The parent group where to store the data of the HDF5 file, by default the parent group is the top group "Brillouin". The format of this group should be "Brillouin/Measure/...". 
    \item \textbf{name\_group} \textit{(optional, default None)}: The name of the group where the elements of the dictionnary are stored. If None, the name is set to "Data\_i" where "i" is an integer that ensures that the name is unique. If the name already corresponds to a group, then the elements of the dictionnary are added in this group unless elements with same name already exist in the group or adding an element would result in more than one raw data in this group. 
    \item \textbf{brillouin\_type} \textit{(optional, default "Measure")}: The type of the group that will store the elements of the dictionnary. The possible values are the ones attributed to groups, defined earlier on in the \hyperref[subsec:preamble.file_structure.complete_structure]{preamble}
\end{itemize}

Here are typical examples of a dictionnary passed as attribute:
\begin{lstlisting}
dic_raw = {
    "Raw_data": {
        "Name": "Raw water spectrum", 
        "Data": np.array([...])}
} # a dictionnary with a raw data array straight from the spectrometer - for example if you want to do the whole anylisis process with the library.

dic_treated = {
    "Raw_data": {
        "Name": "Raw water spectrum", 
        "Data": np.array([...])}
    "PSD": {
        "Name": "PSD water TFP", 
        "Data": np.array([...])},
    "Frequency": {
        "Name": "Frequency", 
        "Data": np.array([...])}
    "Shift": {
        "Name": "Shift", 
        "Data": np.array([...])}
    "Linewidth": {
        "Name": "Shift", 
        "Data": np.array([...])}
    "Abscissa_x": {
        "Name": "x", 
        "Data": np.array([...]),
        "Unit": "microns",
        "Dim_start": 0,
        "Dim_end": 1}
    "Abscissa_y": {
        "Name": "y", 
        "Data": np.array([...]),
        "Unit": "microns",
        "Dim_start": 1,
        "Dim_end": 2},
    "Attributes": {"MEASURE.Sample": "Water",
                   "SPECTROMETER.Type": "TFP"}
} # a dictionnary of measures analyzed by a custom treatment - for example if you have your own data and just want to send them following the library's format.
\end{lstlisting}

\paragraph{Returns:} Nothing

\paragraph{Raises:}

\begin{itemize}
    \item \textbf{WrapperError\_StructureError}: Raises an error if the parent group does not exist in the HDF5 file.
    \item \textbf{WrapperError\_Overwrite}: Raises an error if the group already exists in the parent group.
    \item \textbf{WrapperError\_ArgumentType}: Raises an error if arguments given to the function do not match the expected type.
    \item \textbf{WrapperError\_AttributeError}: Raises an error if arguments given to the function do not match the expected type.
\end{itemize}

\paragraph{Flowchart:}

The function's logic is represented in the following flowchart:
\begin{figure}[H]
    \centering
    \label{fig:wrapper.flowchart_add_dictionnary}
    \small
    \begin{tikzpicture}[node distance=2cm]
        \node (start) [startstop, align=center] {Wrapper.add\_dictionnary(dic, \\parent\_group, name\_group, \\brillouin\_type, overwrite)};
        \node (setParent) [process, below of=start, yshift=0cm, xshift=-3cm] {parent\_group = "Brillouin"};
        \node (checkExists) [process, right of=setParent, xshift=2cm, align=center] {Check if parent\_group \\exists in file};
        \node (raiseError1) [startstop, right of=start, xshift=5cm] {WrapperError\_StructureError};
        \node (checkGroup) [process, right of=setParent, xshift=2cm, align=center] {Check if parent\_group \\is a group};
        \node (getGroup) [process, right of=checkGroup, yshift=-1cm, xshift = 2cm, align=center] {Get the group above\\ parent\_group};
        \node (name0) [process, below of=checkGroup, yshift=-1.8cm, xshift = 4.5cm, align=center] {name\_group\\ = "Data\_i"};
        \node (raiseError2) [process, above of=name0, yshift=0cm, xshift=0cm, yshift=-0.7cm] {i+=1};
        \node (addData) [process, below of=checkExists, yshift=-5cm, xshift=0cm, align=center] {Add each dictionnary \\ element to file in a\\ new group with \\ name \textit{name\_group}};
        \node (iterateKeys) [process, below of=setParent, yshift=-1.5cm, align=center] {For element \textit{e} in dic};
        \node (nameOverwrite) [process, below of=iterateKeys, yshift=0cm, xshift=1.5cm, align=center] {Add/replace element\\to existing group};
        \node (raiseError3) [startstop, below of=iterateKeys, yshift=-2cm, xshift=-0.5cm, align=center] {WrapperError\_Overwrite};
        \node (addAbscissa) [process, below of=addData, yshift=-2cm, align=center] {Create abscissa dataset\\ if element is dictionnary\\ and keys are right. Raises\\ WrapperError\_ArgumentType \\if error};
        \node (raiseError4) [startstop, left of=addAbscissa, xshift=-2.5cm, yshift=2cm, align=center] {WrapperError\_AttributeError};
        \node (addAttributes) [process, left of=addAbscissa, xshift=-2cm, yshift=-1cm, align=center] {Add attributes to\\ the dataset};
        \node (addNormal) [process, right of=addAbscissa, xshift=2.5cm, align=center] {Create dataset\\associated to element};
        \node (end) [startstop, below of=addAbscissa, align=center] {End if everything went well\\ WrapperError if not};

        \draw [arrow] (start) -| node[anchor=east, align=center, yshift=-1cm] {parent\_group \\is None} (setParent);
        \draw [arrow] ++(start.south) -- +(0mm, -0.5cm) -| node[anchor=west, align=center, xshift=0cm, yshift=0.1cm] {parent\_group \\is not None} (checkGroup.north);
        \draw [arrow] (start) -- node[anchor=north, align=center,yshift=0.4cm] {parent\_group \\doesn't exist} (raiseError1);
        \draw [arrow] ++(checkGroup.south) |- +(0cm,-1.5cm) -| +(1cm,-1.5cm) |- node[anchor=west, yshift=1cm, xshift=0cm, align=center] {name\_group\\ is None\\i=0} (name0.west);
        \draw [arrow] (checkGroup) -| node[anchor=west] {is not group} (getGroup);
        \draw [arrow] (checkGroup) |- node[anchor=south, xshift=-1.3cm, align=center] {name\_group\\ in group}(iterateKeys);
        \draw [arrow] ++(iterateKeys.south) |- +(0cm,-0.5cm) -| node[anchor=west, yshift=-1.5cm, xshift=-3.5cm, align=center] {((e["Name"] in group)\\or (e="Raw\_data" \\ and another raw \\  data in group)) \\and overwrite=False} (raiseError3.north);
        \draw [arrow] ++(iterateKeys.south) |- +(0cm,-0.5cm) -| node[anchor=west, yshift=0cm, xshift=0cm, align=center] {else} (nameOverwrite.north);
        \draw [arrow] (raiseError2.south) -| (name0.north);
        \draw [arrow] ++(name0.east) -| +(0.5cm, 0cm)|- node[anchor=west, align=center, yshift=-0.5cm] {name\_group\\ already\\ in group} (raiseError2.east);
        \draw [arrow] (name0) |- node[anchor=west, align=center, xshift=0cm, yshift=0cm] {name\_group not\\ in group} (addData);
        \draw [arrow] ++(checkGroup.south) |- +(0cm, -2cm) -| node[anchor=west, align=center, yshift=-1.8cm] {name\_group not\\ in group} (addData.north);
        \draw [line] (setParent.south) |- (getGroup.west);
        \draw [arrow] (addData) -- node[anchor=west, align=center, yshift=-0.5cm] {element is dict\\ with key "Abscissa\_..."} (addAbscissa);
        \draw [arrow] ++(addData) |- +(0cm,-2.6cm) -| node[anchor=east, align=center, yshift=-1cm] {element\\ is dict with\\ key "Attributes"} (addAttributes);
        \draw [arrow] ++(addData.south) |- node[anchor=south, align=center, xshift=-1cm, yshift=-0.4cm] {element\\ is other} (raiseError4.east);
        \draw [arrow] ++(nameOverwrite.south)|- +(0cm, -2.3cm) -|  (addAbscissa.north);
        \draw [arrow] ++(addData.south) |- +(0cm, -1cm) -| node[anchor=north, align=center, xshift=2.5cm, yshift=0cm] {element is dict\\ with key in "Raw\_data", "PSD",\\"Frequency", "Shift", "Shift\_std"\\ "Linewidth", "Linewidth\_std" \\ or "Other"} (addNormal.north);
        \draw [arrow] (addAbscissa) -- (end);
        \draw [arrow] (addNormal) |- (end);
        \draw [arrow] (addAttributes) |- (end);
    \end{tikzpicture}
    \caption{Flowchart of the add\_dictionnary method}
\end{figure}
