
import numpy as np
import os
from PIL import Image
import h5py
import matplotlib.pyplot as plt
from time_domain import TimeDomain
import re

def load_dat_file(self, filepath):
    """Loads files obtained with the GHOST software

    Parameters
    ----------
    filepath : str                           
        The filepath to the GHOST file
    
    Returns
    -------
    data : np.array
        The data stored in the file
    attributes : dic
        A dictionnary with all the properties that could be recovered from the file
    """
    metadata = {}
    data = []
    name, _ = os.path.splitext(filepath)
    attributes = {}
    
    with open(filepath, 'r') as file:
        lines = file.readlines()
        # Extract metadata
        for line in lines:
            if line.strip() == '':
                continue  # Skip empty lines
            if any(char.isdigit() for char in line.split()[0]):
                break  # Stop at the first number
            else:
                # Split metadata into key-value pairs
                if ':' in line:
                    key, value = line.split(':', 1)
                    metadata[key.strip()] = value.strip()
        # Extract numerical data
        for line in lines:
            if line.strip().isdigit():
                data.append(int(line.strip()))
    data = np.array(data)
    attributes['FILEPROP.Name'] = name.split("/")[-1]
    attributes['MEASURE.Sample'] = metadata["Sample"]
    attributes['SPECTROMETER.Scanning_Strategy'] = "point_scanning"
    attributes['SPECTROMETER.Type'] = "TFP"
    attributes['SPECTROMETER.Illumination_Type'] = "CW"
    attributes['SPECTROMETER.Detector_Type'] = "Photon Counter"
    attributes['SPECTROMETER.Filtering_Module'] = "None"
    attributes['SPECTROMETER.Wavelength_nm'] = metadata["Wavelength"]
    attributes['SPECTROMETER.Scan_Amplitude'] = metadata["Scan amplitude"]
    spectral_resolution = float(float(metadata["Scan amplitude"])/data.shape[-1])
    attributes['SPECTROMETER.Spectral_Resolution'] = str(spectral_resolution)
    return data, attributes

def load_tiff_file(self, filepath):
    """Loads files obtained with the GHOST software

    Parameters
    ----------
    filepath : str                           
        The filepath to the tif image
    
    Returns
    -------
    data : np.array
        The data stored in the file
    attributes : dic
        A dictionnary with all the properties that could be recovered from the file
    """
    data = []
    name, _ = os.path.splitext(filepath)
    attributes = {}

    im = Image.open(filepath)
    data = np.array(im)

    attributes['FILEPROP.Name'] = name

    return data, attributes

def load_dat_timedomain(wrp, filepath):
    """ 
    Loads 2 files containing meta-data:
        - .m file which is automatically generated by UoN's D_scan drivers. This contains relevant oscilloscope settings/data
        - .con file which is the setup/run file for UoN's D_scan drivers. This contains scan parameters, such as x/y steps, etc
    Loads 2 raw data files:
        - .d file which contains the DC measurements (equivalent to Rayleigh peak intensity measurements)
        - .dat binary file which contains the oscillating/AC time signal from the oscilloscope
    This function extracts the various parameters and stores them to wrp.attributes and then
    proceeds with several signal processing protocols to generate a final frequency spectrum.
    These process functions are called from the TimeDomain class defined in time_domain.py

    Parameters
    ----------
    wrp : Wrapper object
        initialised by wrp = Wrapper() in the main run script
    filepath : str                           
        Full filepath to the .dat file
    
    Returns
    -------
    data : np.array
        The data stored in the file (fft_out for time_domain)
    attributes : dic
        A dictionnary with all the properties that could be recovered from the file
    """
    td = TimeDomain()
    print('Filepath for raw data: ', filepath)
    m_data = td.scrape_m_file(filepath)
    td.update_wrapper(wrp, m_data)

    # Read the confile
    con_data = td.scrape_con_file(wrp)
    td.update_wrapper(wrp, con_data)

    # Load and basic processing of .dat file
    data_ac = td.basic_process(wrp, filepath)

    # Extract DC measurements and make units modulation depth
    filepath_dc = filepath[0:len(filepath)-10] + "a2d1_1f.d"
    data_mod = td.load_dc(wrp, data_ac, filepath_dc)

    # Find and crop to signal ROI
    mod_shifted, signal_idxs = td.find_copeaks(wrp, data_mod)
    
    # Build time vector
    data_t, dt = td.make_time(wrp)

    # Low pass filter the signal
    mod_shifted = td.LPfilter(wrp, mod_shifted, dt)

    # Polynomial fit and removal
    data_pro, polyfit = td.polyfit_removal(wrp, mod_shifted)

    # High pass filter the signal
    data_pro = td.HPfilter(wrp, data_pro, dt)

    # Take FFT of the time signal
    fft_out, freqs_out_GHz, fB_GHz = td.take_FFT(wrp, data_pro, dt)
    #wrp.attributes["MEASURE.Abscissa_0"] = freqs_out_GHz

    td.interactive_plot(wrp, data_mod, signal_idxs, polyfit, data_t * 1e9, data_pro, freqs_out_GHz, fft_out, fB_GHz)

    return fft_out, wrp.attributes


def load_general(self, filepath):
    """Loads files based on their extensions

    Parameters
    ----------
    filepath : str                           
        The filepath to the file
    
    Returns
    -------
    data : np.array
        The data stored in the file
    attributes : dic
        A dictionnary with all the properties that could be recovered from the file
    """
    _, file_extension = os.path.splitext(filepath)
    
    if self.attributes["SPECTROMETER.type"] == "time_domain" and file_extension.lower() == ".dat":
        # Load binary .DAT file used in time domain experiments
        return load_dat_timedomain(self, filepath)
    elif file_extension.lower() == ".dat":
        # Load .DAT file format data
        return load_dat_file(self, filepath)
    elif file_extension.lower() == ".tif":
        # Load .TIFF file format data
        return load_tiff_file(self, filepath)
    elif file_extension.lower() == ".h5":
        # Load .TIFF file format data
        return load_hdf5_file(self, filepath)
    else:
        raise ValueError(f"Unsupported file format: {file_extension}")
